## Задание 3. Переход на Event-Driven архитектуру

### Существующие проблемы

На текущий момент явно видны следующие проблемы в интерфейсе с внешними
источниками данных (страховых компаниях):
- используются синхронные вызовы из ```ins-product-aggregator```, которые в
случае задержек или ошибок оказывают негативное влияние на другие сервисы
InsureTech;
- данные внешних компаний размазаны по сервисам внутри InsureTech;
- несмотря на то, что данные из внешних источников скорее всего меняются редко,
InsureTech постоянно пытается получить "самую свежую версию" с достаточно
высокой регулярностью.

Любое из следующих решений можно улучшить общим элементом. Если можно перейти на
Even-Driven взаимодействие со страхоывми компаниями и просто сделать так, чтобы
сервис ```ins-product-aggregator``` ожидал события изменения продуктов и/или
тарифов на их стороне. Тогда отпадет сразу несколько проблем:
- необходимость регулярного опроса API этих компаний в попытке найти изменение
на их стороне;
- необходимость выгружать *все* данные этих компаний вместо небольшого
количества изменений;
- возможная продажа сервисов этих компаний просто из-за того, что данные на
стороне InsureTech устарели и новый цикл их обновления еще не закончился
успешно. 

### Решение текущих проблем и преодоление рисков при расширении бизнеса

Данные проблемы можно решить несколькими методами. Решения представлены в 
многостраничном [draw.io](./InsureTech_C4_сontainer-diagram-updated.drawio)
документе.

#### Решение №1: дабавление кэша в сервисе ins-product-aggregator

Это решение представлено на странице "Cache DB".

Вполне можно предположить, что если InsureTech испытывает технические проблемы
при работе с 5-ю страховыми компаниями, то когда их станет на 5 больше (или в 2
раза больше) проблем меньше не станет. В связи с этим предлагаются следующие
изменения:
- сделать отдельную БД (или просто схему в существующей БД) для сервиса
```ins-product-aggregator```;
- в этой БД будет накапливаться вся информация, поступающая через каналы связи с
другими страховыми компаниями;
- эта БД станет своего рода кэшем для сервисов ```core-app``` и
```ins-comp-settlement```;
- сервис ```ins-product-aggregator``` будет поддерживать эту БД для
удовлетворения всех запросов, поступающих по REST от ```core-app``` и
```ins-comp-settlement```;
- со своей собственной периодичностью ```ins-product-aggregator``` будет
обновлять эту БД;
- необходимость хранить дубликат данных в сервисах ```core-app``` и
```ins-comp-settlement``` исчезнет и для устранения дальнейших проблем
рекомендуется эти данные либо удалить из этих сервисов, либо перенести в новую
БД как ее начальное состояние.
В итоге мы получим новую БД, которая будет работать как кэш между страховыми
компаниями и сервисами InsureTech и по сути заменим синхронные запросы к внешним
данным на асинхронные.

Плюсы этого решения:
- уменьшается количество запросов к API страховых компаний;
- функционал сервисов ```core-app``` и ```ins-comp-settlement``` никак не
меняется - все запросы так и остаются синхронными;
- решается проблема долгих или упавших запросов из-за проблем на стороне внешних
источников данных;
- исчезает необходимость дублирования данных из внешних источников во внутренних
сервисах InsureTech (немного уменьшится объем БД);
- появится один "источник правды", так как из-за ошибок в вызовах копии внешних
данных в ```core-app``` и ```ins-comp-settlement``` могут рассинхронизоваться;
- вместо ошибки из-за таймаута внутренние сервисы будут получать наиболее
свежую копию внешних данных из кэша.

Минусы этого решения:
- возможно предоставление устаревших данных от внешних источников из-за задержки
с их обновлением во внутренней БД.

#### Решение №2: добавление очереди сообщений между сервисами

Это решение представлено на странице "Message Queue".

Можно решить проблему ошибок в запросах из ```core-app``` и
```ins-comp-settlement``` путем внедрения очереди сообщений и переключении этих
сервисов на асинхронную работу с ```ins-product-aggregator```. Это позволит
отказаться от каких-либо расписаний в работе этих сервисов для обновления своих
данных и просто ожидать событий о том, что эти данные обновились. При этом
```ins-product-aggregator``` в случае обновления данных будет генерировать
сособытие "данные обновились" и прилагать к нему все необходимые данные для
сервисов ```core-app``` и ```ins-comp-settlement```. Тут обязательно внедрение
Transactional Outbox. В свою очередь последние два сервиса станут подписчиками
на подобные события.

Плюсы этого решения:
- уменьшается количество лишних запросов к внешним источникам. Теперь вместо
трёх сервисов только один будет запрашивать API страховых компаний;
- сервисы ```core-app``` и ```ins-comp-settlement``` больше не занимаются
активностью по принудительному обновлению собственной копии внешних данных;
- данные в ```core-app``` и ```ins-comp-settlement``` синхронны;
- исчезают ошибки в работе двух сервисов, связанных с ошибками вне InsureTech.

Минусы этого решения:
- полная переработка интерфейса взаимодействия с ```ins-product-aggregator```
для перехода с REST на асинхронную работу;
- расходы на поддержание новой сущности в виде очереди сообщения и защиты от
проблем с ее доступностью (например, кластеризация).
