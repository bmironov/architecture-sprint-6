## Задание 4. Проектирование продажи ОСАГО

Данное задание выполнено в многостраничном
[draw.io документе](./InsureTech_C4_сontainer-diagram-OSAGO.drawio). Для
удобства на странице "Message Queue" приведена одна из диаграмм предыдущего
задания, которая наиболее подходит для этого задание. Решение приведено на
странице "OSAGO".

### Требования к новому сервису

Новый сервис ```osago-aggregator``` должен выполнять следующим критическим
условиям:
- обслуживание до 25000 запросов на квоты ОСАГО одновременно
(2500 клиентов * 10 страховых компаний);
- отображать полученные квоты сразу при их получении на экране пользователя;
- ждать на web клиенте квот ОСАГО не дольше 60 секунд.

1. Первое условие скорее всего будет иметь хороший шанс генерировать
повторяющиеся запросы, так как марок автомобилей не так много. Поэтому какое-то
кэширование квот от страховых компаний поможет обеим стороноам бизнеса:
- снизит зависимость от производительности систем обеих компаний и возможность
их инфраструктуры поддерживать большое количество запросов;
- позволит выдавать клиенту больше квот и таким образом повысить вероятность
всем участникам предложить свои услуги, тем самым повысить конкурентность
предложения и возможно снизить цены для покупателя ОСАГО. Параллельно с этим
InsureTech может иметь большую маржу на этих сделках;
- прикрыть страховые компании и продолжать предлагать их квоты даже когда их
сервисы недоступны по каким-то причинам вместо простого вычеркивания их из
списка предложений;
- можно договориться о том как долго квота будет оставаться в силе и таким
образом повысить эффективность данного кэша.

2. Второе условие не позволяет реализовать синхронные вызовы "в цикле по списку"
так как проблемы и задержки в API одной компании будут съедать время на обмен
информацией с остальными компаниями. Поэтому единственным решением тут может
быть только асинхронный метод.

### Реализация сервиса osago-aggregator

В качестве кэша сервиса osago-aggregator можно использовать Redis с его
возможностью создавать элементы данных с заранее указанным expiration time.
Этим будет поддерживаться актуальность квот. Для оптимизации объема хранимых
квот для ключа вычисляется хэш значение например на основании JSON, где собраны
все параметры квоты, вся информация приведена к одному регистру, удалены
ненужные пробелы и ключи отсортированы.

Асинхронный метод общения сервисов внутри компании будет осуществляться через
топик Kafka (Kafka была введена в инфраструктуру компании в прошлом задании)
примерно следующим образом:
- клиент InsureTech Web откроет WebSocket к ```core-app``` и отправит через него
запрос на получение квот, при этом на экране активируется регион для отображения
квот;
- ```core-app``` сгенерирует команду в специальном топике Kafka для получения
квот ОСАГО с определенными параметрами в пэйлоаде;
- ```osago-aggregator``` примет данную команду и преобразует ее в вызовы для
проверки кэша ```osago-aggregator-db``` с такими параметрами от всех
участвующих страховых компаний;
- если данные обнаружены в кэше, то на их основе создаются сообщения в очередь
для передачи в ```core-app```, иначе отправляется запрос в страховую компанию
на получение квоты. В случае успешного получения квоты от компании, резульиат
сохраняется в кэше и если 60 секунд не закончились, то отправляется сообщение
для ```core-app```;
- ```core-app``` принимает сообщения от ```osago-aggregator``` и высылает данные
по WebSocket в приложение.

Скорее всего обработка запросов квот ОСАГО будет осуществляться через свою
очередь. Это позволит сделать запросы к страховым компаниям параллельными и
осуществлять их несколькими k8s подами, что позволит гибко управлять
масштабированием этой части ```osago-aggregator```. Параллельно с этим легче
будет реализовать обработку таймаутов, повторных вызовов API компаний и
ограничение количества запросов к этим API.

Так как запрос квот - это довольно тяжелый процесс, то на уровне интерфейса
между ```InsureTech Web``` и ```core-app``` необходимо установить ограничитель
количества таких запросов (rate limiter) и circuit breaker.
